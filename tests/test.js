/**
 * @file test.js generated by Gemini 2.5 Pro AI to test rcv-core-logic Ranked Choice Voting library.
 * @description
 * A simple test suite for the rcv-core-logic library.
 * Run this file using `node test.js` in your terminal.
 * You can also add "test": "node test.js" to the "scripts" section of your package.json and run npm test
 */

// Import the functions to be tested
// The './' is important – it tells Node to look for a local file.
const { validateVote, formatBallots, tally } = require('../index.js');

// A simple test runner helper
let testCount = 0;
let passCount = 0;

function test(description, testFunction) {
  testCount++;
  try {
    testFunction();
    passCount++;
    console.log(`\x1b[32m  ✔ PASS:\x1b[0m ${description}`); // Green text for pass
  } catch (error) {
    console.error(`\x1b[31m  ✖ FAIL:\x1b[0m ${description}`); // Red text for fail
    console.error(error);
  }
}

// Helper for deep equality check (simple version)
function assertEqual(actual, expected, msg) {
  const actualJson = JSON.stringify(actual);
  const expectedJson = JSON.stringify(expected);
  if (actualJson !== expectedJson) {
    throw new Error(
      `${msg}\n    Expected: ${expectedJson}\n    Got:      ${actualJson}`
    );
  }
}

// ---------------------------------
// 1. validateVote() Tests
// ---------------------------------
console.log('\nRunning tests for validateVote()...');
const TEST_CANDIDATES = ['A', 'B', 'C'];

test('should return valid for a correct ballot', () => {
  const ballot = { rankings: ['A', 'C', 'B'], approvals: ['A'] };
  const result = validateVote(ballot, TEST_CANDIDATES);
  assertEqual(result, { valid: true, error: null }, 'Valid ballot failed');
});

test('should return invalid for a duplicate candidate in rankings', () => {
  const ballot = { rankings: ['A', 'B', 'A'] };
  const result = validateVote(ballot, TEST_CANDIDATES);
  assertEqual(
    result,
    {
      valid: false,
      error: 'Duplicate found: rankings contain repeated options.',
    },
    'Duplicate candidate check failed'
  );
});

test('should return invalid for a duplicate candidate in approvals', () => {
  const ballot = { rankings: ['A', 'B'], approvals: ['A', 'A'] };
  const result = validateVote(ballot, TEST_CANDIDATES);
  assertEqual(
    result,
    {
      valid: false,
      error: 'Duplicate found: approvals contain repeated options.',
    },
    'Duplicate approval check failed'
  );
});

test('should return invalid for an unknown candidate in rankings', () => {
  const ballot = { rankings: ['C', 'D', 'A'] };
  const result = validateVote(ballot, TEST_CANDIDATES);
  assertEqual(
    result,
    {
      valid: false,
      error: `Invalid choice: "D" is not one of the options.`,
    },
    'Unknown candidate check failed'
  );
});

test('should return invalid for an unknown candidate in approvals', () => {
  const ballot = { rankings: ['A', 'B'], approvals: ['D'] };
  const result = validateVote(ballot, TEST_CANDIDATES);
  assertEqual(
    result,
    {
      valid: false,
      error: `Invalid approved choice: "D" is not one of the options.`,
    },
    'Unknown approved candidate check failed'
  );
});

test('should return valid for a partial ballot', () => {
  const ballot = { rankings: ['B', 'A'] };
  const result = validateVote(ballot, TEST_CANDIDATES);
  assertEqual(result, { valid: true, error: null }, 'Partial ballot failed');
});

test('should return invalid for a ballot containing a non-string choice in rankings', () => {
  const ballot = { rankings: ['A', 123, 'C'] }; // 123 is a number, not a string
  const result = validateVote(ballot, TEST_CANDIDATES);
  assertEqual(
    result,
    {
      valid: false,
      error: 'Invalid choice: rankings contain a non-string value.',
    },
    'Non-string choice in ranking check failed'
  );
});

test('should return invalid for a ballot containing a non-string choice in approvals', () => {
  const ballot = { rankings: ['A', 'B'], approvals: [123] }; // 123 is a number, not a string
  const result = validateVote(ballot, TEST_CANDIDATES);
  assertEqual(
    result,
    {
      valid: false,
      error: 'Invalid choice: approvals contain a non-string value.',
    },
    'Non-string choice in approval check failed'
  );
});

// ---------------------------------
// 2. formatBallots() Tests
// ---------------------------------
console.log('\nRunning tests for formatBallots()...');

test('should filter out invalid and malformed ballots', () => {
  const rawVotes = [
    { userId: 'u-1', rankings: ['A', 'B'], approvals: ['A'] }, // Valid
    { userId: 'u-2', rankings: ['B', 'A', 'B'] }, // Invalid (duplicate)
    { userId: 'u-3', rankings: ['C'] }, // Valid
    { userId: 'u-4', rankings: ['D'] }, // Invalid (unknown)
    { userId: 'u-5', rankings: ['A', 'C'], approvals: ['A', 'C'] }, // Valid
    { userId: 'u-6', otherProp: 'foo' }, // Malformed (no .rankings)
    null, // Malformed (null vote)
  ];
  const expected = [
    { rankings: ['A', 'B'], approvals: ['A'] },
    { rankings: ['C'], approvals: [] },
    { rankings: ['A', 'C'], approvals: ['A', 'C'] },
  ];
  const result = formatBallots(rawVotes, TEST_CANDIDATES);
  assertEqual(result, expected, 'Ballot formatting failed');
});

test('should return an empty array for empty input', () => {
  const result = formatBallots([], TEST_CANDIDATES);
  assertEqual(result, [], 'Empty input did not return empty array');
});

// ---------------------------------
// 3. tally() Tests
// ---------------------------------
console.log('\nRunning tests for tally()...');
const TEST_CONFIG = {
  tieBreaking: 'approval',
  maxRounds: 10,
};

test('should find a winner in a single round (clear majority)', () => {
  const ballots = [
    { rankings: ['A', 'B', 'C'] },
    { rankings: ['A', 'C', 'B'] },
    { rankings: ['B', 'A', 'C'] },
    { rankings: ['A', 'B', 'C'] },
  ];
  const results = tally(ballots, TEST_CANDIDATES, TEST_CONFIG);
  assertEqual(results.winner, 'A', 'First-round winner test failed');
  assertEqual(results.rounds.length, 1, 'First-round winner test had >1 round');
  assertEqual(
    results.rounds[0].tally,
    { A: 3, B: 1, C: 0 },
    'First-round tally incorrect'
  );
});

test('should find a winner in multiple rounds (elimination)', () => {
  // This is the example from the README
  const ballots = [
    { rankings: ['A', 'B', 'C'] },
    { rankings: ['B', 'A', 'C'] },
    { rankings: ['A', 'C', 'B'] },
    { rankings: ['C', 'B', 'A'] },
    { rankings: ['B', 'A', 'C'] },
  ];
  const candidates = ['A', 'B', 'C'];
  const results = tally(ballots, candidates, TEST_CONFIG);

  assertEqual(results.winner, 'B', 'Multi-round winner incorrect');
  assertEqual(results.rounds.length, 2, 'Multi-round election rounds incorrect');
  // Check Round 1
  assertEqual(
    results.rounds[0].status,
    'Elimination',
    'Round 1 status incorrect'
  );
  assertEqual(
    results.rounds[0].eliminated,
    ['C'],
    'Round 1 elimination incorrect'
  );
  // Check Round 2
  assertEqual(
    results.rounds[1].status,
    'Winner found',
    'Round 2 status incorrect'
  );
  assertEqual(
    results.rounds[1].tally,
    { A: 2, B: 3 },
    'Round 2 tally incorrect'
  );
});

test('should handle an unbreakable tie', () => {
  const ballots = [
    { rankings: ['A', 'B'] },
    { rankings: ['B', 'A'] },
  ];
  const candidates = ['A', 'B'];
  const results = tally(ballots, candidates, TEST_CONFIG);
  assertEqual(results.winner, null, 'Tie test did not result in null winner');
  assertEqual(
    results.rounds[results.rounds.length - 1].status,
    'Unbreakable tie',
    'Tie test status incorrect'
  );
});

test('should handle exhausted ballots correctly', () => {
  const ballots = [
    { rankings: ['A', 'B'] },
    { rankings: ['A', 'B'] },
    { rankings: ['B', 'A'] },
    { rankings: ['B', 'A'] },
    { rankings: ['C'] }, // This ballot will be exhausted after C is eliminated
  ];
  const candidates = ['A', 'B', 'C'];
  const results = tally(ballots, candidates, TEST_CONFIG);

  // Round 1: Tally is {A: 2, B: 2, C: 1}. C is eliminated.
  // C's 1 vote is transferred to "exhausted".
  // Round 2: Tally is {A: 2, B: 2}. This is an unbreakable tie.
  assertEqual(results.winner, null, 'Exhausted ballot test winner incorrect');
  assertEqual(
    results.rounds.length,
    2,
    'Exhausted ballot test round count incorrect'
  );
  assertEqual(
    results.rounds[0].transfers.C.exhausted,
    1,
    'Did not correctly log exhausted ballot transfer'
  );
  assertEqual(
    results.rounds[1].status,
    'Unbreakable tie',
    'Exhausted ballot test did not end in a tie'
  );
});

test('should use approval votes to break a tie', () => {
  const ballots = [
    { rankings: ['A', 'B'], approvals: ['A'] },
    { rankings: ['B', 'A'], approvals: ['B'] },
    { rankings: ['A', 'C'], approvals: ['A'] },
    { rankings: ['C', 'A'], approvals: ['C'] },
    { rankings: ['B', 'C'], approvals: ['B'] },
    { rankings: ['C', 'B'], approvals: ['C'] },
  ];
  const candidates = ['A', 'B', 'C'];
  const results = tally(ballots, candidates, TEST_CONFIG);

  // Round 1: Tally is {A: 2, B: 2, C: 2}. Tie for elimination.
  // Approval counts: A: 2, B: 2, C: 2. Still a tie.
  // All are eliminated.
  assertEqual(results.winner, null, 'Approval tie break test winner incorrect');
  assertEqual(
    results.rounds[0].status,
    'Unbreakable tie',
    'Approval tie break test did not end in a tie'
  );
});

test('should use approval votes to break a tie and find a winner', () => {
  const ballots = [
    { rankings: ['A', 'B'], approvals: ['A'] },
    { rankings: ['B', 'A'], approvals: ['B'] },
    { rankings: ['A', 'C'], approvals: ['A'] },
    { rankings: ['C', 'A'], approvals: [] },
    { rankings: ['B', 'C'], approvals: ['B'] },
    { rankings: ['C', 'B'], approvals: ['C'] },
  ];
  const candidates = ['A', 'B', 'C'];
  const results = tally(ballots, candidates, TEST_CONFIG);

  // Round 1: Tally is {A: 2, B: 2, C: 2}. Tie for elimination.
  // Approval counts: A: 2, B: 2, C: 1. C is eliminated.
  // Round 2: Tally is {A: 3, B: 3}. Tie.
  // Approval counts for A and B are equal, so it's an unbreakable tie.
  assertEqual(results.winner, null, 'Approval tie break winner test winner incorrect');
  assertEqual(
    results.rounds.length,
    2,
    'Approval tie break winner test round count incorrect'
  );
  assertEqual(
    results.rounds[0].eliminated,
    ['C'],
    'Approval tie break winner test round 1 elimination incorrect'
  );
  assertEqual(
    results.rounds[1].status,
    'Unbreakable tie',
    'Approval tie break winner test did not end in a tie'
  );
});

// ---------------------------------
// Final Summary
// ---------------------------------
console.log('\n---------------------------------');
console.log('         Test Summary');
console.log('---------------------------------');
console.log(`  Total Tests: ${testCount}`);
if (passCount === testCount) {
  console.log(`\x1b[32m  Passed:      ${passCount}\x1b[0m`); // Green
  console.log('\x1b[32m\n  All tests passed! ✨\x1b[0m');
} else {
  console.log(`\x1b[32m  Passed:      ${passCount}\x1b[0m`); // Green
  console.log(`\x1b[31m  Failed:      ${testCount - passCount}\x1b[0m`); // Red
  console.log('\x1b[31m\n  Some tests failed.\x1b[0m');
}
console.log('---------------------------------\n');